由于golang是边学边写，估计写的很丑，比如server所有代码放在一起了。
server使用AVL树保存kv对，以key排序。AVL树的实现是摘自某个博客，我自行添加了parent指针，以
支持getnext这种操作。
client每次会发一个key作为请求，服务器会查找这个key对应的value，及下一个key，一起返回给
客户端，客户端拿着value用于输出，拿着key用于下一次请求。

尝试添加了go test。除了服务器每次随机产生200个key之外（随机字符串生成函数也是抄的网上的某个博客，还没细看)
，为了简化测试，人为地在服务端kv对中添加一个固定的kv pair。
服务器对每个请求会生成一个正确结果文件，客户端会把收到的数据写到一个文件，测试会比较这两个文件，比较方法较粗糙
地使用golang来调用diff shell命令，检查输出是否为空。
文件的命名是:客户端IP:客户端口，测试程序在结束前会删除这些临时文件。
开了server之后，在client目录执行go test -v

【没实现优化】服务器对每个请求都返回接近MSS/sizeof(kv pair)，客户端发现用完这么多数据
后才会再一次请求

